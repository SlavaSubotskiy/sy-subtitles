name: Subtitle Pipeline

on:
  push:
    branches: [main]
    paths:
      - 'talks/*/transcript_en.txt'
  workflow_dispatch:
    inputs:
      talk_id:
        description: 'Talk directory name (e.g., 1993-09-19_Ganesha-Puja-Cabella)'
        required: true
        type: string
      translate:
        description: 'Run translate step'
        type: boolean
        default: true
      review:
        description: 'Run review step'
        type: boolean
        default: true
      build:
        description: 'Run build step (subtitle builder agent)'
        type: boolean
        default: true

permissions:
  contents: write
  id-token: write

jobs:
  discover:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.find.outputs.matrix }}
      talk_matrix: ${{ steps.find.outputs.talk_matrix }}
      whisper_matrix: ${{ steps.find.outputs.whisper_matrix }}
      needs_whisper: ${{ steps.find.outputs.needs_whisper }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Install pyyaml
        run: pip install pyyaml

      - name: Find talks, videos, and pending whisper
        id: find
        run: |
          python3 << 'PYEOF'
          import json, os, subprocess, yaml

          talk_id_input = "${{ inputs.talk_id }}".strip()
          video_includes = []
          talk_ids = set()
          whisper_talk_ids = set()

          def process_talk(talk_id):
              meta_path = f"talks/{talk_id}/meta.yaml"
              if not os.path.isfile(meta_path):
                  print(f"SKIP: {meta_path} not found")
                  return
              talk_ids.add(talk_id)
              with open(meta_path) as f:
                  meta = yaml.safe_load(f)
              for v in meta.get("videos", []):
                  slug = v["slug"]
                  video_includes.append({"talk_id": talk_id, "video_slug": slug})
                  whisper_path = f"talks/{talk_id}/{slug}/source/whisper.json"
                  if not os.path.isfile(whisper_path):
                      whisper_talk_ids.add(talk_id)
                      print(f"WHISPER NEEDED: {talk_id}/{slug}")
                  else:
                      print(f"READY: {talk_id}/{slug}")

          if talk_id_input:
              process_talk(talk_id_input)
          else:
              result = subprocess.run(
                  ["git", "diff", "--name-only", "HEAD~1", "HEAD"],
                  capture_output=True, text=True
              )
              for line in result.stdout.strip().split("\n"):
                  if "transcript_en.txt" in line:
                      parts = line.split("/")
                      if len(parts) >= 2:
                          process_talk(parts[1])

          matrix = json.dumps({"include": video_includes})
          talk_matrix = json.dumps({"include": [{"talk_id": t} for t in sorted(talk_ids)]})
          whisper_matrix = json.dumps({"include": [{"talk_id": t} for t in sorted(whisper_talk_ids)]})
          needs_whisper = "true" if whisper_talk_ids else "false"

          print(f"\nTalks: {len(talk_ids)}, Videos: {len(video_includes)}, Talks needing whisper: {len(whisper_talk_ids)}")

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"matrix={matrix}\n")
              f.write(f"talk_matrix={talk_matrix}\n")
              f.write(f"whisper_matrix={whisper_matrix}\n")
              f.write(f"needs_whisper={needs_whisper}\n")
          PYEOF

  # Run Whisper for talks that don't have whisper.json yet
  whisper:
    needs: discover
    if: needs.discover.outputs.needs_whisper == 'true'
    strategy:
      matrix: ${{ fromJson(needs.discover.outputs.whisper_matrix) }}
      fail-fast: false
    uses: ./.github/workflows/whisper.yml
    with:
      talk_id: ${{ matrix.talk_id }}

  # Translate EN→UK and review with 2+1 process (per talk)
  translate-and-review:
    needs: discover
    if: inputs.translate != false || inputs.review != false
    environment: main
    strategy:
      matrix: ${{ fromJson(needs.discover.outputs.talk_matrix) }}
      fail-fast: false
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Cache Claude Code
        uses: actions/cache@v4
        with:
          path: |
            ~/.claude-code
            ~/.local/share/claude-code
          key: claude-code-${{ runner.os }}

      - name: Install Claude Code
        run: bun install -g @anthropic-ai/claude-code@latest

      - name: Resolve executable paths
        id: tools
        run: |
          echo "bun=$(which bun)" >> "$GITHUB_OUTPUT"
          echo "claude=$(which claude)" >> "$GITHUB_OUTPUT"

      - name: Translate to Ukrainian
        if: inputs.translate != false
        uses: anthropics/claude-code-action@v1
        env:
          CLAUDE_CODE_MAX_OUTPUT_TOKENS: "64000"
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          path_to_bun_executable: ${{ steps.tools.outputs.bun }}
          path_to_claude_code_executable: ${{ steps.tools.outputs.claude }}
          claude_args: "--max-turns 30 --dangerously-skip-permissions --model claude-opus-4-6"
          show_full_output: true
          prompt: |
            You are translating a Sahaja Yoga lecture from English to Ukrainian.

            REQUIRED READING — read these files before translating:
            1. glossary/CLAUDE.md — transliteration conventions, capitalization rules
            2. glossary/terms_lookup.yaml — EN→UK term dictionary (374 terms)
            3. glossary/terms_context.yaml — disambiguation context for ambiguous terms
            4. glossary/chakra_map.yaml — chakra/deity/channel mapping
            5. talks/${{ matrix.talk_id }}/transcript_en.txt — English source transcript
            (CLAUDE.md is auto-loaded — no need to read it)

            TASK:
            Translate the full English transcript into Ukrainian and write it to:
              talks/${{ matrix.talk_id }}/transcript_uk.txt

            RULES:
            - Skip the header lines (date, title, location, "Talk Language:" line) — translate ONLY the speech content
            - Preserve paragraph structure: one EN paragraph = one UK paragraph
            - One paragraph per line (single \n between paragraphs)
            - No header, no metadata, no line numbers in the output file
            - Follow ALL language rules from CLAUDE.md
            - Use glossary terms consistently (terms_lookup.yaml + terms_context.yaml)
            - Follow transliteration conventions from glossary/CLAUDE.md (ґ not г for Sanskrit g, дх for dh, і for short i)
            - Translate with devotion, precision, and respect for the sacred meaning

            WRITING STRATEGY (important — the transcript is too large for a single Write):
            Write the translation in chunks of ~3-5 KB each using bash:
            ```bash
            # First chunk — create file
            cat > talks/${{ matrix.talk_id }}/transcript_uk.txt << 'UKEOF'
            Перший абзац...
            Другий абзац...
            UKEOF

            # Next chunks — APPEND
            cat >> talks/${{ matrix.talk_id }}/transcript_uk.txt << 'UKEOF'
            Наступний абзац...
            UKEOF
            ```
            Do not try to write everything in one call. Split into as many chunks as needed.
            Do not summarize, abbreviate, or skip any paragraphs.
            Do not use TodoWrite — this runs in CI, no one sees progress updates.

      - name: Verify translation exists
        run: |
          if [ ! -f "talks/${{ matrix.talk_id }}/transcript_uk.txt" ]; then
            echo "::error::transcript_uk.txt was not created by translate step"
            exit 1
          fi
          echo "transcript_uk.txt exists ($(wc -c < "talks/${{ matrix.talk_id }}/transcript_uk.txt") bytes)"

      - name: Review translation (2+1)
        if: inputs.review != false
        uses: anthropics/claude-code-action@v1
        env:
          CLAUDE_CODE_MAX_OUTPUT_TOKENS: "64000"
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          path_to_bun_executable: ${{ steps.tools.outputs.bun }}
          path_to_claude_code_executable: ${{ steps.tools.outputs.claude }}
          claude_args: "--max-turns 25 --dangerously-skip-permissions --model claude-opus-4-6"
          show_full_output: true
          prompt: |
            Perform a 2+1 language review on the Ukrainian translation.

            READ these files:
            1. talks/${{ matrix.talk_id }}/transcript_uk.txt — the translation to review
            2. talks/${{ matrix.talk_id }}/transcript_en.txt — English original for reference
            3. templates/language_review_template.md — review process and table format
            4. glossary/CLAUDE.md — SY terminology and capitalization rules
            5. glossary/terms_lookup.yaml — term dictionary
            6. glossary/terms_context.yaml — disambiguation context
            (CLAUDE.md is auto-loaded — no need to read it)

            PROCESS (follow templates/language_review_template.md):

            Step 1 — Reviewer L (Language):
            Check orthography, grammar, punctuation:
            - Spelling, incorrect word forms, mixed Latin/Cyrillic characters
            - Comma usage, quotation marks «», em-dash ` — `, ellipsis `...`
            - Case forms, verb conjugations, gender agreement
            - Missing/extra spaces around punctuation

            Step 2 — Reviewer S (SY Domain):
            Check terminology and capitalization:
            - Deity pronoun capitalization per CLAUDE.md rules
            - Glossary term consistency against terms_lookup.yaml
            - SY terminology accuracy
            - Language names lowercase in Ukrainian
            - Spiritual term capitalization (Дхарма, Інкарнація, Пуджа, Дух, Істина, Стопи)

            Step 3 — Critic:
            Review ALL corrections from L and S:
            - Remove false positives (where original was correct)
            - Remove trivial style preferences (not real errors)
            - Keep only genuine errors with clear justification
            - Resolve conflicts between L and S suggestions

            Step 4 — Apply:
            Apply all Critic-approved corrections to talks/${{ matrix.talk_id }}/transcript_uk.txt
            Save the full review report (with all tables) to talks/${{ matrix.talk_id }}/review_report.md

            Be thorough but precise. Only change what genuinely needs correction.
            Do not use TodoWrite — this runs in CI, no one sees progress updates.

      - name: Upload translation artifacts
        uses: actions/upload-artifact@v4
        with:
          name: translation__${{ matrix.talk_id }}
          if-no-files-found: error
          path: |
            talks/${{ matrix.talk_id }}/transcript_uk.txt
            talks/${{ matrix.talk_id }}/review_report.md

  # Build Ukrainian subtitles using Claude agent (per talk, handles multi-video offset)
  build-subtitles:
    needs: [discover, whisper, translate-and-review]
    if: |
      always() &&
      !cancelled() &&
      needs.discover.result == 'success' &&
      (needs.translate-and-review.result == 'success' || needs.translate-and-review.result == 'skipped') &&
      (needs.whisper.result == 'success' || needs.whisper.result == 'skipped')
    environment: main
    strategy:
      matrix: ${{ fromJson(needs.discover.outputs.talk_matrix) }}
      fail-fast: false
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Pull latest (whisper may have pushed)
        run: git pull --rebase

      - name: Download translation artifacts
        if: needs.translate-and-review.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: translation__${{ matrix.talk_id }}
          path: talks/${{ matrix.talk_id }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Cache Claude Code
        uses: actions/cache@v4
        with:
          path: |
            ~/.claude-code
            ~/.local/share/claude-code
          key: claude-code-${{ runner.os }}

      - name: Install Claude Code
        run: bun install -g @anthropic-ai/claude-code@latest

      - name: Resolve executable paths
        id: tools
        run: |
          echo "bun=$(which bun)" >> "$GITHUB_OUTPUT"
          echo "claude=$(which claude)" >> "$GITHUB_OUTPUT"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-pipeline-${{ hashFiles('requirements.txt') }}
          restore-keys: pip-pipeline-

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Check prerequisites
        run: |
          TALK="talks/${{ matrix.talk_id }}"

          if [ ! -f "$TALK/transcript_uk.txt" ]; then
            echo "ERROR: $TALK/transcript_uk.txt not found"
            exit 1
          fi

          python3 -c "
          import yaml, sys
          with open('$TALK/meta.yaml') as f:
            meta = yaml.safe_load(f)
          ok = True
          for v in meta['videos']:
            slug = v['slug']
            for f in ['source/en.srt', 'source/whisper.json']:
              path = f'$TALK/{slug}/{f}'
              import os
              if not os.path.isfile(path):
                print(f'ERROR: {path} not found')
                ok = False
              else:
                print(f'OK: {path}')
          if not ok:
            sys.exit(1)
          "

      - name: Build subtitles
        if: inputs.build != false
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          path_to_bun_executable: ${{ steps.tools.outputs.bun }}
          path_to_claude_code_executable: ${{ steps.tools.outputs.claude }}
          claude_args: "--max-turns 25 --dangerously-skip-permissions --model claude-opus-4-6"
          show_full_output: true
          prompt: |
            You are building Ukrainian subtitles for a Sahaja Yoga lecture.

            TALK: talks/${{ matrix.talk_id }}/
            Read meta.yaml to discover all videos for this talk.

            STEP 0 — Compute EN SRT boundary:
            Before building, determine the talk's time boundary. Run:
              python3 -c "
              import re
              with open('talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/source/en.srt') as f:
                  blocks = re.findall(r'(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})', f.read())
              print(f'EN SRT: {len(blocks)} blocks, ends at {blocks[-1][1]}')
              "
            Replace FIRST_VIDEO_SLUG with the actual first video slug from meta.yaml.
            Save the EN SRT end time — you will pass it to the builder.

            STEP 1 — Build subtitles for the FIRST video:
            Use the Task tool to spawn a builder sub-agent:
              - subagent_type: "general-purpose"
              - prompt: |
                  Read templates/subtitle_builder_template.md for full instructions.
                  Build Ukrainian subtitles for the first video.
                  INPUT FILES:
                  - Ukrainian text: talks/${{ matrix.talk_id }}/transcript_uk.txt
                  - English subtitles: talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/source/en.srt
                  - Whisper data: talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/source/whisper.json
                  OUTPUT: talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/final/uk.srt
                  Create output dir first: mkdir -p "talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/final"

                  CRITICAL WHISPER BOUNDARY: The EN SRT ends at {EN_END_TIME}.
                  The whisper.json may cover a much longer recording (e.g., 2h puja).
                  You MUST ONLY use whisper segments within the EN SRT time range.
                  Your UK SRT MUST NOT extend beyond {EN_END_TIME}.
                  IGNORE all whisper segments after this time.

                  Process in ~5-minute chunks. After all chunks, validate:
                  python -m tools.validate_subtitles \
                    --srt "talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/final/uk.srt" \
                    --transcript "talks/${{ matrix.talk_id }}/transcript_uk.txt" \
                    --whisper-json "talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/source/whisper.json" \
                    --report "talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/final/report.txt"
                  If text preservation fails, fix and re-validate.
                  Do not use TodoWrite — this runs in CI.
            Replace FIRST_VIDEO_SLUG and {EN_END_TIME} with actual values.

            STEP 2 — Handle remaining videos:
            For each additional video in meta.yaml, detect offset:
              python -m tools.offset_srt detect \
                --srt1 "talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/source/en.srt" \
                --srt2 "talks/${{ matrix.talk_id }}/NEXT_VIDEO_SLUG/source/en.srt"
            If offset detected — apply it:
              mkdir -p "talks/${{ matrix.talk_id }}/NEXT_VIDEO_SLUG/final"
              python -m tools.offset_srt apply \
                --srt "talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/final/uk.srt" \
                --offset-ms OFFSET \
                --output "talks/${{ matrix.talk_id }}/NEXT_VIDEO_SLUG/final/uk.srt"
            IMPORTANT: Do NOT trim or modify the offset SRT file after applying.
            Some blocks may extend beyond the shorter video's duration — this is expected.
            Do NOT write Python scripts to modify SRT files.
            If no offset (different content) — spawn another builder sub-agent for that video.

            STEP 3 — Validate ALL videos:
            For the FIRST video (full validation):
              python -m tools.validate_subtitles \
                --srt "talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/final/uk.srt" \
                --transcript "talks/${{ matrix.talk_id }}/transcript_uk.txt" \
                --whisper-json "talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/source/whisper.json" \
                --report "talks/${{ matrix.talk_id }}/FIRST_VIDEO_SLUG/final/report.txt"
            For offset videos (skip text and time checks — different video duration):
              python -m tools.validate_subtitles \
                --srt "talks/${{ matrix.talk_id }}/OFFSET_VIDEO_SLUG/final/uk.srt" \
                --transcript "talks/${{ matrix.talk_id }}/transcript_uk.txt" \
                --whisper-json "talks/${{ matrix.talk_id }}/OFFSET_VIDEO_SLUG/source/whisper.json" \
                --skip-text-check --skip-time-check \
                --report "talks/${{ matrix.talk_id }}/OFFSET_VIDEO_SLUG/final/report.txt"

            Once validation passes, STOP. Do not review or rebuild.
            Do not use TodoWrite — this runs in CI, no one sees progress updates.

      - name: Upload build artifacts
        if: inputs.build != false && !cancelled()
        uses: actions/upload-artifact@v4
        with:
          name: subtitles__${{ matrix.talk_id }}
          path: |
            talks/${{ matrix.talk_id }}/*/final/uk.srt
            talks/${{ matrix.talk_id }}/*/final/report.txt

      - name: Validate subtitles
        if: inputs.build != false
        run: |
          TALK="talks/${{ matrix.talk_id }}"

          # Find the longest video (by whisper duration) — that's the one built by the agent
          BUILT_SLUG=$(python3 -c "
          import json, yaml
          with open('$TALK/meta.yaml') as f:
            meta = yaml.safe_load(f)
          best_slug, best_dur = None, 0
          for v in meta['videos']:
            wpath = f'$TALK/{v[\"slug\"]}/source/whisper.json'
            try:
              with open(wpath) as wf:
                segs = json.load(wf)['segments']
              dur = segs[-1]['end'] if segs else 0
            except (FileNotFoundError, KeyError, IndexError):
              dur = 0
            if dur > best_dur:
              best_dur = dur
              best_slug = v['slug']
          print(best_slug)
          ")

          python3 -c "
          import yaml
          with open('$TALK/meta.yaml') as f:
            meta = yaml.safe_load(f)
          for v in meta['videos']:
            print(v['slug'])
          " | while read slug; do
            VIDEO="$TALK/$slug"
            EXTRA_FLAGS=""
            if [ "$slug" != "$BUILT_SLUG" ]; then
              EXTRA_FLAGS="--skip-text-check --skip-time-check"
            fi
            python -m tools.validate_subtitles \
              --srt "$VIDEO/final/uk.srt" \
              --transcript "$TALK/transcript_uk.txt" \
              --whisper-json "$VIDEO/source/whisper.json" \
              $EXTRA_FLAGS \
              --report "$VIDEO/final/report.txt"
          done

  # Single commit job — collects all artifacts and pushes
  commit:
    needs: [discover, translate-and-review, build-subtitles]
    if: |
      always() &&
      !cancelled() &&
      (needs.build-subtitles.result == 'success' || needs.build-subtitles.result == 'failure' || needs.build-subtitles.result == 'skipped') &&
      (needs.translate-and-review.result == 'success' || needs.translate-and-review.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Pull latest
        run: git pull --rebase

      - name: Download translation artifacts
        if: needs.translate-and-review.result == 'success'
        uses: actions/download-artifact@v4
        with:
          pattern: translation__*
          merge-multiple: false

      - name: Download subtitle artifacts
        if: needs.build-subtitles.result == 'success'
        uses: actions/download-artifact@v4
        with:
          pattern: subtitles__*
          merge-multiple: false

      - name: Place artifacts into talk directories
        run: |
          # Debug: show artifact structure
          echo "=== Artifact contents ==="
          find translation__* subtitles__* -type f 2>/dev/null || true
          echo "========================="

          # Place translation artifacts
          for dir in translation__*/; do
            [ -d "$dir" ] || continue
            name="${dir%/}"
            talk_id="${name#translation__}"
            echo "Processing translation: $talk_id"

            # Find files anywhere in artifact dir (upload-artifact strips LCA)
            for f in transcript_uk.txt review_report.md; do
              src=$(find "$dir" -name "$f" -type f | head -1)
              if [ -n "$src" ]; then
                mkdir -p "talks/$talk_id"
                cp "$src" "talks/$talk_id/$f"
                echo "  -> talks/$talk_id/$f"
              fi
            done
          done

          # Place subtitle artifacts (per-talk, contains all videos)
          # Artifact structure: subtitles__TALK/VIDEO/final/{uk.srt,report.txt}
          # (upload-artifact strips LCA = talks/TALK/)
          for dir in subtitles__*/; do
            [ -d "$dir" ] || continue
            name="${dir%/}"
            talk_id="${name#subtitles__}"
            echo "Processing subtitles: $talk_id"

            find "$dir" \( -name "uk.srt" -o -name "report.txt" \) | while read src; do
              rel="${src#$name/}"
              dest="talks/$talk_id/$rel"
              mkdir -p "$(dirname "$dest")"
              cp "$src" "$dest"
              echo "  -> $dest"
            done
          done

      - name: Commit & push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add talks/*/transcript_uk.txt talks/*/review_report.md \
                talks/*/*/final/uk.srt talks/*/*/final/report.txt
          git diff --cached --quiet && { echo "No changes to commit"; exit 0; }
          git commit -m "Build subtitles (full pipeline)"
          git pull --rebase
          git push
